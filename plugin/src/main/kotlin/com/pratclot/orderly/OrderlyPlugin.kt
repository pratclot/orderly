/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.pratclot.orderly

import com.android.build.gradle.AppExtension
import com.android.build.gradle.LibraryExtension
import com.pratclot.orderly.data.ProjectType
import com.pratclot.orderly.tasks.CreateSubproject
import com.pratclot.orderly.tasks.experimental.CreateSubprojectWithInitPlugin
import com.pratclot.orderly.tools.ProjectNotYetGeneratedException
import com.pratclot.orderly.tools.getApiCommon
import com.pratclot.orderly.tools.getApiCommonLive
import com.pratclot.orderly.tools.getCommonAndroid
import com.pratclot.orderly.tools.getCommonAndroidTest
import com.pratclot.orderly.tools.getCommonKotlin
import com.pratclot.orderly.tools.getCommonKotlinTest
import com.pratclot.orderly.tools.getDomain
import com.pratclot.orderly.tools.getDto
import com.pratclot.orderly.tools.getFeatureName
import com.pratclot.orderly.tools.getProjectByPath
import com.pratclot.orderly.tools.isAndroidApp
import com.pratclot.orderly.tools.isAndroidLibrary
import com.pratclot.orderly.tools.isApiCommon
import com.pratclot.orderly.tools.isApiCommonLive
import com.pratclot.orderly.tools.isApiLive
import com.pratclot.orderly.tools.isApp
import com.pratclot.orderly.tools.isCommonAndroid
import com.pratclot.orderly.tools.isCommonAndroidTest
import com.pratclot.orderly.tools.isCommonKotlin
import com.pratclot.orderly.tools.isCommonKotlinTest
import com.pratclot.orderly.tools.isDto
import com.pratclot.orderly.tools.isJavaLibrary
import com.pratclot.orderly.tools.isLayerApiFeature
import com.pratclot.orderly.tools.isLayerApiFeatureCommonApi
import com.pratclot.orderly.tools.isLayerRepository
import com.pratclot.orderly.tools.isLayerScreen
import com.pratclot.orderly.tools.isLayerUsecase
import org.gradle.api.Plugin
import org.gradle.api.Project

const val EMPTY_STRING = ""
const val BUILD_FILE_NAME = "build.gradle.kts"
const val GITIGNORE_FILE_NAME = ".gitignore"

enum class DefaultFeatureLayers(val projectType: ProjectType) {
    SCREEN(ProjectType.ANDROID_LIB),
    USECASE(ProjectType.JAVA_LIB),
    REPOSITORY(ProjectType.JAVA_LIB),
    API(ProjectType.JAVA_LIB),
}

const val TASK_CREATE_SUBPROJECT_API_COMMON = "createSubprojectApiCommon"
const val TASK_CREATE_SUBPROJECT_API_COMMON_LIVE = "createSubprojectApiCommonLive"
const val TASK_CREATE_SUBPROJECT_DOMAIN = "createSubprojectDomain"
const val TASK_CREATE_SUBPROJECT_DTO = "createSubprojectDto"
const val TASK_CREATE_SUBPROJECT_COMMON_KOTLIN = "createSubprojectCommonKotlin"
const val TASK_CREATE_SUBPROJECT_COMMON_KOTLIN_TEST = "createSubprojectCommonKotlinTest"
const val TASK_CREATE_SUBPROJECT_COMMON_ANDROID = "createSubprojectCommonAndroid"
const val TASK_CREATE_SUBPROJECT_COMMON_ANDROID_TEST = "createSubprojectCommonAndroidTest"
const val TASK_CREATE_SUBPROJECT_FEATURE = "createSubprojectFeature"
const val TASK_CREATE_ALL = "createAllSubprojects"

const val TASK_ALL_UNIT_TESTS = "runAllUnitTests"

const val CONFIGURATION_IMPLEMENTATION = "implementation"
const val CONFIGURATION_TEST_IMPLEMENTATION = "testImplementation"
const val CONFIGURATION_KAPT = "kapt"
const val CONFIGURATION_COMPILE_CLASSPATH = "compileClasspath"
const val CONFIGURATION_API = "api"

/**
 * TODO: This looks more like a test dependency, and is not very maintanable.
 */
enum class CreateSubprojectTasks(val taskName: String, val defaultPath: String) {
    API_COMMON(
        TASK_CREATE_SUBPROJECT_API_COMMON,
        ":$DEFAULT_DIR_NAME_API:$DEFAULT_DIR_NAME_API_COMMON"
    ),
    API_COMMON_LIVE(
        TASK_CREATE_SUBPROJECT_API_COMMON_LIVE,
        ":$DEFAULT_DIR_NAME_API:$DEFAULT_DIR_NAME_API_COMMON_LIVE"
    ),
    DOMAIN(TASK_CREATE_SUBPROJECT_DOMAIN, ":$DEFAULT_DIR_NAME_DOMAIN"),
    DTO(TASK_CREATE_SUBPROJECT_DTO, ":$DEFAULT_DIR_NAME_DTO"),
    COMMON_KOTLIN(
        TASK_CREATE_SUBPROJECT_COMMON_KOTLIN,
        ":$DEFAULT_DIR_NAME_COMMON:$DEFAULT_DIR_NAME_COMMON_KOTLIN"
    ),
    COMMON_ANDROID(
        TASK_CREATE_SUBPROJECT_COMMON_ANDROID,
        ":$DEFAULT_DIR_NAME_COMMON:$DEFAULT_DIR_NAME_COMMON_ANDROID"
    ),
    COMMON_KOTLIN_TEST(
        TASK_CREATE_SUBPROJECT_COMMON_KOTLIN_TEST,
        ":$DEFAULT_DIR_NAME_COMMON:$DEFAULT_DIR_NAME_COMMON_KOTLIN_TEST"
    ),
    COMMON_ANDROID_TEST(
        TASK_CREATE_SUBPROJECT_COMMON_ANDROID_TEST,
        ":$DEFAULT_DIR_NAME_COMMON:$DEFAULT_DIR_NAME_COMMON_ANDROID_TEST"
    ),
}

/**
 * A simple 'hello world' plugin.
 */
class OrderlyPlugin : Plugin<Project>, OrderlyPluginAbstraction {
    override lateinit var project: Project
    override lateinit var extension: OrderlyPluginExtension

    private val features get() = extension.features.get()
    private val layers get() = DefaultFeatureLayers.values()

    private val featureTasks: List<FeatureTask>
        get() = features
            .map { featureName -> featureName.lowercase().replaceFirstChar { it.uppercase() } }
            .flatMap { featureName ->
                layers.flatMap { layer ->
                    val layerName = layer.toString().lowercase().replaceFirstChar { it.uppercase() }
                    val layerDir = layer.toString().lowercase()
                    val featureDir = featureName.lowercase()
                    val layerType = layer.projectType
                    (listOf(
                        "mock",
                        "live",
                        "commonapi"
                    ).takeIf { layer == DefaultFeatureLayers.API }
                        ?: listOf(""))
                        .map { variantName ->
                            FeatureTask(
                                taskName = "$TASK_CREATE_SUBPROJECT_FEATURE$featureName$layerName${variantName.replaceFirstChar { it.uppercase() }}",
                                dir = "$layerDir/$featureDir/$variantName",
                                projectType = layerType,
                            )
                        }
                }
            }

    private val commonTaskNames get() = CreateSubprojectTasks.values().map { it.taskName }
    private val featureTaskNames get() = featureTasks.map { it.taskName }

    data class FeatureTask(
        val taskName: String,
        val dir: String,
        val projectType: ProjectType,
    )

    override fun apply(project1: Project) {

        project = project1
        extension = project.extensions.create(EXTENSION_NAME, OrderlyPluginExtension::class.java)

        /**
         * [Project.afterEvaluate] allows to access user-supplied properties in [OrderlyPluginExtension].
         *
         * Actually, this is all black magic, so I do not ask questions as long as it works.
         */
        project.afterEvaluate {
            setupLayerDependencyGraph()

            registerCommonSubprojectCreationTasks()
            registerFeatureSubprojectCreationTasks()
            registerCreateAllTask()

//            applyHiltPlugin()
        }
        project.gradle.projectsEvaluated {
            setupUnitTests()
        }
    }

    /**
     * This seemingly straightforward operation will give you this:
     *
     * Caused by: java.lang.IllegalStateException: The Hilt Android Gradle plugin can only be applied to an Android project.
     *
     * if the plugin project does NOT depend on "com.google.dagger:hilt-android-gradle-plugin:2.42".
     */
    private fun applyHiltPlugin() {
        project.subprojects { proj ->
            proj.plugins.withId("com.android.application") {
                proj.pluginManager.apply("dagger.hilt.android.plugin")
            }
            proj.plugins.withId("com.android.library") {
                proj.plugins.apply("dagger.hilt.android.plugin")
            }
        }
    }

    private fun setupInstrumentedTests() {
        project.subprojects.filter { it.isAndroidLibrary() }.forEach {
            it.extensions.getByType(LibraryExtension::class.java).apply {
                defaultConfig {
                    testInstrumentationRunner = extension.testInstrumentationRunner.get()
                }
                testOptions {
                    animationsDisabled = true
                }
            }
        }
    }

    /**
     * Experimental, used to avoid template maintenance and creating dir structure by hand!
     */
    private fun experiment() {
        project.tasks.register(
            "createSubprojectWithInitPluginApiCommon",
            CreateSubprojectWithInitPlugin::class.java
        ).get().apply {
            projectDirConfigurable.set("api/common")
            type = "kotlin-library"
            dsl = "groovy"
        }
    }

    private fun registerCommonSubprojectCreationTasks() {
        project.tasks.register(TASK_CREATE_SUBPROJECT_API_COMMON, CreateSubproject::class.java)
            .get().apply {
                val path = with(extension) { "${dirNameApi.get()}/${dirNameApiCommon.get()}" }
                dir.set(path)
                projectType.set(ProjectType.JAVA_LIB)
                packageName.set(extension.packageName.get())

                val expectedProjectDir = project.rootDir.resolve(path)
                val expectedPackageDir = extension.packageName.get().replace('.', '/')
                val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                projectDir.set(expectedProjectDir)
                buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
            }

        project.tasks.register(TASK_CREATE_SUBPROJECT_API_COMMON_LIVE, CreateSubproject::class.java)
            .get().apply {
                val path = with(extension) { "${dirNameApi.get()}/${dirNameApiCommonLive.get()}" }
                dir.set(path)
                projectType.set(ProjectType.JAVA_LIB)
                packageName.set(extension.packageName.get())

                val expectedProjectDir = project.rootDir.resolve(path)
                val expectedPackageDir = extension.packageName.get().replace('.', '/')
                val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                projectDir.set(expectedProjectDir)
                buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
            }

        project.tasks.register(TASK_CREATE_SUBPROJECT_DOMAIN, CreateSubproject::class.java)
            .get()
            .apply {
                val path = with(extension) { "${dirNameDomain.get()}" }
                dir.set(path)
                projectType.set(ProjectType.JAVA_LIB)
                packageName.set(extension.packageName.get())

                val expectedProjectDir = project.rootDir.resolve(path)
                val expectedPackageDir = extension.packageName.get().replace('.', '/')
                val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                projectDir.set(expectedProjectDir)
                buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
            }

        project.tasks.register(TASK_CREATE_SUBPROJECT_DTO, CreateSubproject::class.java).get()
            .apply {
                val path = with(extension) { "${dirNameDto.get()}" }
                dir.set(path)
                projectType.set(ProjectType.JAVA_LIB)
                packageName.set(extension.packageName.get())

                val expectedProjectDir = project.rootDir.resolve(path)
                val expectedPackageDir = extension.packageName.get().replace('.', '/')
                val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                projectDir.set(expectedProjectDir)
                buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
            }

        project.tasks.register(TASK_CREATE_SUBPROJECT_COMMON_KOTLIN, CreateSubproject::class.java)
            .get()
            .apply {
                val path = with(extension) { "${dirNameCommon.get()}/${dirNameCommonKotlin.get()}" }
                dir.set(path)
                projectType.set(ProjectType.JAVA_LIB)
                packageName.set(extension.packageName.get())

                val expectedProjectDir = project.rootDir.resolve(path)
                val expectedPackageDir = extension.packageName.get().replace('.', '/')
                val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                projectDir.set(expectedProjectDir)
                buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
            }

        project.tasks.register(
            TASK_CREATE_SUBPROJECT_COMMON_KOTLIN_TEST,
            CreateSubproject::class.java
        )
            .get()
            .apply {
                val path =
                    with(extension) { "${dirNameCommon.get()}/${dirNameCommonKotlinTest.get()}" }
                dir.set(path)
                projectType.set(ProjectType.JAVA_LIB)
                packageName.set(extension.packageName.get())

                val expectedProjectDir = project.rootDir.resolve(path)
                val expectedPackageDir = extension.packageName.get().replace('.', '/')
                val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                projectDir.set(expectedProjectDir)
                buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
            }

        project.tasks.register(TASK_CREATE_SUBPROJECT_COMMON_ANDROID, CreateSubproject::class.java)
            .get()
            .apply {
                val path =
                    with(extension) { "${dirNameCommon.get()}/${dirNameCommonAndroid.get()}" }
                dir.set(path)
                projectType.set(ProjectType.ANDROID_LIB)
                packageName.set(extension.packageName.get())

                val expectedProjectDir = project.rootDir.resolve(path)
                val expectedPackageDir = extension.packageName.get().replace('.', '/')
                val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                val expectedManifestPath = "src/main/AndroidManifest.xml"
                projectDir.set(expectedProjectDir)
                buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
                manifestFile.set(projectDir.get().resolve(expectedManifestPath))
            }

        project.tasks.register(
            TASK_CREATE_SUBPROJECT_COMMON_ANDROID_TEST,
            CreateSubproject::class.java
        )
            .get()
            .apply {
                val path =
                    with(extension) { "${dirNameCommon.get()}/${dirNameCommonAndroidTest.get()}" }
                dir.set(path)
                projectType.set(ProjectType.ANDROID_LIB)
                packageName.set(extension.packageName.get())

                val expectedProjectDir = project.rootDir.resolve(path)
                val expectedPackageDir = extension.packageName.get().replace('.', '/')
                val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                val expectedManifestPath = "src/main/AndroidManifest.xml"
                projectDir.set(expectedProjectDir)
                buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
                manifestFile.set(projectDir.get().resolve(expectedManifestPath))
            }
    }

    /**
     * A handle to create all subprojects.
     */
    private fun registerCreateAllTask() {
        project.tasks.register(TASK_CREATE_ALL).get().apply {
            dependsOn(commonTaskNames)
            dependsOn(featureTaskNames)
        }
    }

    /**
     * Blahblahblah.
     */
    private fun setupLayerDependencyGraph() {
        applyPluginsToSubprojects()
        setupJavaLibraries()
        setupAndroidLibraries()
        setupAndroidApp()
        setupInstrumentedTests()
    }

    private fun setupUnitTests() {
        project.tasks.register(TASK_ALL_UNIT_TESTS).get().apply {
            project.subprojects.forEach {
                if (it.isJavaLibrary()) {
                    dependsOn(it.tasks.getByName("test"))
                }
                if (it.isCommonAndroid()) {
                    dependsOn(it.tasks.getByName("testDebugUnitTest"))
                }
                if (it.isLayerScreen()) {
                    val featureNameUppercase =
                        it.getFeatureName().replaceFirstChar { it.uppercase() }
                    dependsOn(it.tasks.getByName("test${featureNameUppercase}LiveDebugUnitTest"))
                }
            }
        }
    }

    private fun setupAndroidApp() {
        project.subprojects.filter { it.isAndroidApp() }.forEach {

            it.plugins.apply("com.android.application")
//            it.plugins.apply("org.jetbrains.kotlin.android")

//            it.dependencies.add(CONFIGURATION_KAPT, "com.google.dagger:hilt-compiler:2.42")
//            it.dependencies.add(CONFIGURATION_IMPLEMENTATION, "com.google.dagger:hilt-android:2.42")

            extension.features.get()
                .forEach { name ->
                    it.extensions.getByType(AppExtension::class.java).run {
                        flavorDimensionList.add("${name}Data")
                        productFlavors.create("${name}Mock") {
                            it.dimension = "${name}Data"
                        }
                        productFlavors.create("${name}Live") {
                            it.dimension = "${name}Data"
                        }
                    }
                    try {
                        it.dependencies.add(
                            CONFIGURATION_IMPLEMENTATION,
                            getProjectByPath(":screen:$name")
                        )
                    } catch (ex: ProjectNotYetGeneratedException) {
//                    it's ok
                    }
                }

            it.setupDebugMinifyBuildType()
        }
    }

    private fun setupAndroidLibraries() {
        project.subprojects.filter { it.isAndroidLibrary() }.forEach {
            it.repositories.apply {
                google()
            }
            it.plugins.apply("com.android.library")
            it.plugins.apply("org.jetbrains.kotlin.android")
            it.plugins.apply("dagger.hilt.android.plugin")

            it.dependencies.add(CONFIGURATION_KAPT, "com.google.dagger:hilt-compiler:2.42")
            it.dependencies.add(CONFIGURATION_IMPLEMENTATION, "com.google.dagger:hilt-android:2.42")

            it.dependencies.add(
                CONFIGURATION_IMPLEMENTATION,
                getCommonKotlin()
            )

            if (it.isCommonAndroidTest()) {
                it.dependencies.add(
                    CONFIGURATION_IMPLEMENTATION,
                    getCommonKotlinTest()
                )
            } else if (it.isCommonAndroid()) {
            } else {
                val name = it.getFeatureName()
                it.extensions.getByType(LibraryExtension::class.java).run {
                    flavorDimensions.add("${name}Data")
                    productFlavors.create("${name}Mock") {
                        it.dimension = "${name}Data"
                    }
                    productFlavors.create("${name}Live") {
                        it.dimension = "${name}Data"
                    }
                }

                it.dependencies.add(
                    CONFIGURATION_IMPLEMENTATION,
                    getProjectByPath(":usecase:${name}")
                )
                it.dependencies.add(
                    CONFIGURATION_IMPLEMENTATION,
                    getDomain()
                )
                it.dependencies.add(
                    CONFIGURATION_IMPLEMENTATION,
                    getCommonAndroid()
                )
                it.dependencies.add(
                    CONFIGURATION_TEST_IMPLEMENTATION,
                    getCommonKotlinTest()
                )
                it.dependencies.add(
                    CONFIGURATION_TEST_IMPLEMENTATION,
                    getCommonAndroidTest()
                )

                it.setupDebugMinifyBuildType()
            }
        }
    }

    private fun Project.setupDebugMinifyBuildType() {
        val extensionClass = when {
            isLayerScreen() -> LibraryExtension::class.java
            isApp() -> AppExtension::class.java
            else -> throw IllegalArgumentException("Attempting to configure debugMinify for an unknown project type")
        }
        extensions.getByType(extensionClass).run {
            val debugBuildType = buildTypes.getByName("debug")
            buildTypes.create("debugMinify").run {
                initWith(debugBuildType)
                if (isApp()) applicationIdSuffix = ".debugMinify"
                minifyEnabled(true)
                proguardFiles.add(getDefaultProguardFile("proguard-android-optimize.txt"))
                proguardFiles.add(rootDir.resolve("proguard-rules.pro"))
            }
        }
    }

    private fun applyPluginsToSubprojects() {
        extension.commonPlugins.get().forEach { pluginId ->
            project.subprojects {
                it.plugins.apply(pluginId)
            }
        }
    }

    private fun setupJavaLibraries() {
        project.subprojects.filter { it.isJavaLibrary() }.forEach {
            it.plugins.apply("org.jetbrains.kotlin.jvm")
        }
        project.subprojects.filter { it.isLayerApiFeature() }.forEach {
            it.dependencies.run {
                add(CONFIGURATION_IMPLEMENTATION, getDto())
                add(CONFIGURATION_IMPLEMENTATION, getApiCommon())
                kotlin.runCatching {
                    add(
                        CONFIGURATION_IMPLEMENTATION,
                        getProjectByPath(it.projectDir.parentFile.resolve("commonapi").path)
                    )
                }.exceptionOrNull()?.let {
                    println("Could not add dependency: $it")
                }
            }
        }
        project.subprojects.filter { it.isLayerApiFeatureCommonApi() }.forEach {
            it.dependencies.run {
                add(CONFIGURATION_IMPLEMENTATION, getDto())
                add(CONFIGURATION_IMPLEMENTATION, getApiCommon())
            }
        }
        extension.dependenciesApiCommonLiveStrings.get().let { deps ->
            project.subprojects.filter { it.isApiCommonLive() }.forEach { project ->
                deps.forEach {
                    project.dependencies.api(it)
                }
            }
        }
        project.subprojects.filter { it.isApiLive() }.forEach {
            it.dependencies.add(CONFIGURATION_IMPLEMENTATION, getApiCommonLive())

            val featureName = it.getFeatureName()
            it.dependencies.add(
                CONFIGURATION_IMPLEMENTATION, getProjectByPath(":api:$featureName:commonapi")
            )
        }
        project.subprojects.filter { it.isApiCommon() }.forEach {
            it.dependencies.add(CONFIGURATION_IMPLEMENTATION, getDto())
        }
        project.subprojects.filter { it.isLayerRepository() }.forEach {
            it.dependencies.add(CONFIGURATION_IMPLEMENTATION, getDomain())
            it.dependencies.add(CONFIGURATION_IMPLEMENTATION, getDto())
            it.dependencies.add(CONFIGURATION_IMPLEMENTATION, getApiCommon())

            val featureName = it.getFeatureName()
            runCatching {
                it.dependencies.add(
                    CONFIGURATION_IMPLEMENTATION,
                    getProjectByPath(":api:$featureName:mock")
                )
            }
            runCatching {
                it.dependencies.add(
                    CONFIGURATION_IMPLEMENTATION,
                    getProjectByPath(":api:$featureName:live")
                )
            }
            runCatching {
                it.dependencies.add(
                    CONFIGURATION_IMPLEMENTATION,
                    getProjectByPath(":api:$featureName:commonapi")
                )
            }
        }
        project.subprojects.filter { it.isLayerUsecase() }.forEach {
            it.dependencies.add(CONFIGURATION_IMPLEMENTATION, getDomain())

            val featureName = it.getFeatureName()
            it.dependencies.add(
                CONFIGURATION_IMPLEMENTATION,
                getProjectByPath(":repository:$featureName")
            )
        }
        project.subprojects
            .filter { it.isJavaLibrary() }
            .filter { !it.isCommonKotlin() }
            .forEach {
                it.dependencies.add(CONFIGURATION_IMPLEMENTATION, getCommonKotlin())
            }
        project.subprojects
            .filter { it.isJavaLibrary() }
            .forEach {
                it.run {
                    implementation("com.google.dagger:hilt-core:2.42")
                    kapt("com.google.dagger:hilt-compiler:2.42")
                    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.2")
                    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0")

                    dependencies.add(
                        CONFIGURATION_TEST_IMPLEMENTATION,
                        getCommonKotlinTest()
                    )
                }
            }
        project.subprojects.filter { it.isDto() }.forEach {
            it.plugins.apply("org.jetbrains.kotlin.plugin.serialization")
        }
        project.subprojects.filter { it.isCommonKotlinTest() }
            .forEach {

            }
    }

    /**
     * These tasks will create layers-subprojects defined in [DefaultFeatureLayers] for every declared feature.
     */
    private fun registerFeatureSubprojectCreationTasks() {
        featureTasks.forEach { (taskName, layerDir, layerType) ->
            project.tasks.register(taskName, CreateSubproject::class.java)
                .get()
                .apply {
                    dir.set(layerDir)
                    projectType.set(layerType)
                    packageName.set(extension.packageName.get())

                    val expectedProjectDir = project.rootDir.resolve(layerDir)
                    val expectedPackageDir = extension.packageName.get().replace('.', '/')
                    val expectedSrcPathMain = "src/main/kotlin/$expectedPackageDir"
                    val expectedSrcPathTest = "src/test/kotlin/$expectedPackageDir"
                    val expectedManifestPath = "src/main/AndroidManifest.xml"
                    projectDir.set(expectedProjectDir)
                    buildFile.set(projectDir.get().resolve(BUILD_FILE_NAME))
                    gitIgnoreFile.set(projectDir.get().resolve(GITIGNORE_FILE_NAME))
                    srcDirKotlin.set(projectDir.get().resolve(expectedSrcPathMain))
                    srcDirTest.set(projectDir.get().resolve(expectedSrcPathTest))
                    manifestFile.set(projectDir.get().resolve(expectedManifestPath))
                }
        }
    }
}

fun Project.implementation(target: String) =
    dependencies.add(CONFIGURATION_IMPLEMENTATION, target)

fun Project.kapt(target: String) = dependencies.add(CONFIGURATION_KAPT, target)
